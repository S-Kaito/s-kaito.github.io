<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="../style.css">
	<script type="text/javascript" src="../script.js" defer></script>
	<title>A Tutorial on Graph-Based SLAM - SLAM論文</title>
</head>
<body>
	<div class="wrapper">
		<h1>A Tutorial on Graph-Based SLAM</h1>
		<h2>はじめに</h2>
		不確実性の下での地図の作成はSLAM問題と呼ばれる。この文献では、この問題に対するさまざまな使用可能である解決案がある。これらのアプローチは、フィルタリングまたは平滑化のいずれかに分類できる。フィルタリングアプローチは、システムの状態が現在のロボットの位置と地図で構成されるオンライン状態推定として問題をモデル化する。新しい測定値が利用可能になったときにそれを組み込むことによって、地図の拡張および改良を行う。有名な手法としてはカルマン情報フィルタ、パーティクルフィルタ等がある。これらは主にオンラインSLAMメソッドと呼ばれる。対して、平滑化アプローチは、測定した情報セットからロボットの完全な軌道を推定する。これらの手法は最小二乗問題として扱われる。<br>
		SLAM問題に対処する直感的な方法は、いわゆるグラフベースによる定式化であろう。ロボットの姿勢やランドマークを頂点、それらを関係づけるセンサデータを辺としたグラフの解決により、SLAM問題を解くことが出来る。しかし、観測は常にノイズの影響を受けるため、このような制約が矛盾する可能性がある。このようなグラフが作成されると、測定値と最大限に一致するノードの構成を見つけることが重要な問題となる。これは、誤差最小化問題となる。<br>
		グラフベースSLAMは1997年にLuとMiliosらによって提案された。当時は複雑な計算が必要であったため流行らなかったが、現在では有力なアプローチとなっている。このチュートリアルの目的は、SOTA(state-of-the-art)なグラフベースのSLAMの理解へ読者を導くことである。このチュートリアルを理解するには、線形代数、多変量最小化、および確率論に関する十分な知識が必要である。
		
		<h2>SLAMの確率論的定式化</h2>
		<div style="text-align: center;">
			m: 地図<br>
			<img src="public01/pic/Formula01.png" alt="">: ロボットの軌道<br>
			<img src="public01/pic/Formula02.png" alt="">: オドメトリ<br>
			<img src="public01/pic/Formula03.png" alt="">: 環境情報<br>
		</div>
		<br><br>
		上記の変数の定義の上で完全SLAM問題は以下のように定義されます。<br>

		<div class="figure">
			<img src="public01/pic/Formula04.png" alt="">
			<div class="figure-text">式01 完全SLAMの定式化</div>
		</div>
		ポーズxとオドメトリuは様々な方法で表現できます。例えば、占有グリッド(occupancy grids)、表面マップ(surface maps)、生なセンサデータ値としても表現可能である。環境や使用するアルゴリズムによってそれは使い分けられる。ランドマークによる地図は環境の特徴量が識別可能な時に好んで用いられる。特にカメラ使用時に使われる。逆に密な地図表現は通常距離センサと合わせて用いられる。これらのデータは測定値と測定した場所のペアで保存される。式01で与えられた事後処理を推定するには高次元の状態空間を操作する必要がある。この構造は、静的世界の仮定とマルコフの仮定という、ある種の一般的に行われている仮定に由来する。この構造を記述する便利な方法として、図1に示す動的ベイズネットワーク(DBN)がある。これは再帰的モデルである。
		
		<div class="comment">
			この「○○の仮定」という表現はSLAMの全てのデータは「推定したデータに過ぎない」という思想の元の表現であると思われる。が、知識不足の可能性の方が高いので、今後「マルコフの仮定」等の単語も調べる必要があるかもしれない。
		</div>

		<div class="figure">
			<img src="public01/pic/DynamicBayesianNetwork.png" alt="">
			<div class="figure-text">図01 動的ベイズネットワーク</div>
		</div>

		DBNに代わる表現としては「グラフベース」、「ネットワークベース」等がある。グラフベースSLAMではロボットの姿勢をグラフとしてモデル化する。グラフベースSLAMは「グラフ構築」と「グラフ最適化」の二つの問題から成る。

		<div class="comment">
			グラフベースSLAMの説明の多くは省かせて頂いた。その多くが<a href="../index.html#IntroductionToSLAM">SLAM入門</a>と類似しており、これを読んでいるあなたはもう既に理解している事柄であるためである。
		</div>
		
		<h2>関連研究</h2>
		ここに関連研究を挙げる。このチュートリアルではグラフベースSLAMに焦点を当てているので、そのようなアプローチを検討する。
		<ul>
			<li>
				<b>Lu, Milions</b><br>
				方程式全体を最適化することで誤差を減らし、地図を洗礼する手法を最初に提案した。
			</li>
			<li>
				<b>Gutmann, Konolige</b><br>
				増分推定アルゴリズムを実行しながらループ閉じ込みを検出する手法を提案した。これ以降、様々なネットワーク最適化の手法が提案された。
			</li>
			<li>
				<b>Howardetら</b><br>
				「relaxation」を適応してロボット位置を特定する。
			</li>
			<li>
				<b>Freseら</b><br>
				「multi-level Relaxation(MLR)」と呼ばれるGauss-Seidel relaxationを提案した。それは異なる解像度でのrelaxationを適用している。
			</li>
			<li>
				<b>Dellaert, Kaess</b><br>
				オフラインSLAMへの適応のために疎行列因数分解を用いた。
			</li>
			<li>
				<b>Kaesset ら</b><br>
				疎な因数分解を計算するために部分的な並び替えを利用したオンラインSLAM「ediSAM」を発表。
			</li>
			<li>
				<b>Konoligeet ら</b><br>
				線形化されたシステムを効率的に構築するためのポーズグラフ法のオープンソースで提案した。
			</li>
			<li>
				<b>Olson ら</b><br>
				確率的勾配降下法に基づいた効率的な最適化手法を提案。
			</li>
			<li>
				<b>Grisetti</b><br>
				Olsonのアプローチを拡張し、2Dと3Dのノードを木構造で扱うアプローチを提案した。 このようにして収束速度を向上させている。
			</li>
			<li>
				<b>GraphSLAM</b><br>
				最適化問題の次元を減らすために変数消去技術を用いている。
			</li>
			<li>
				<b>The ATLAS フレームワーク</b><br>
				2階層でグラフを構築し、最下層ではカルマン・フィルタを用い、第2レベルではローカルマップを整列させて大域最適化アプローチを行う。
			</li>
			<li>
				<b>Estrada ら</b><br>
				独立した小域地図を用いた「Hierarchical SLAM」を提案
			</li>
			<li>
				<b>Olson</b><br>
				フロントエンド部分でのスペクトルクラスタリングを用いた外れ値除去
			</li>
			<li>
				<b>N ̈uchter ら</b><br>
				3Dマッピングを統合的に行うSLAM
			</li>
			<li>
				<b>Lu, Milios</b><br>
				Nuchterらの提案した3D SLAMの最適化
			</li>
		</ul>
		
		<h2>グラフベースSLAM</h2>
		グラフベースSLAMでは生のセンサデータを抽象化した「仮想の測定値」で単純化された測定問題を構築します。何故なら、推定プロセスでデータを単純化せずに扱うと、組み合わせの複雑さが爆発的に増大することになる。そのため、ほとんどの実用的なアプローチでは、最も可能性の高いトポロジーに推定値を限定している。<br>
		正しいデータ関連付けを計算するためには、フロントエンドではロボットの軌跡<img src="public01/pic/Formula05.png" alt="">上の条件付き優先順位を一貫して推定する必要がある。ロボットが環境を探索する際には、フロントエンドとバックエンドの実行を連動させる必要があり、バックエンドの精度と効率性は、良いSLAMシステムを設計する上で非常に重要である。このチュートリアルでは、データ関連付け問題に対する高度なアプローチは説明しない。必要ならば、スペクトルクラスタリング、ジョイント互換性分岐とバインド、またはバックトラッキングを用いたアソシエーションに取り組もう。<br>
		観測値が正規分布に従ってノイズの影響を受けるとき、グラフベースマッピングアルゴリズムの目的はロボットの軌道の事後確率を求めることである。これは観測の尤度が最大になるようなグラフの構成を計算する問題だ。以下ではこの問題を<b>制約最適化問題</b>と呼び、以下に表記法を紹介する。<br>
		<img src="public01/pic/Formula06.png" alt="">は姿勢を示す行列であり、<img src="public01/pic/Formula07.png" alt="">及び<img src="public01/pic/Formula08.png" alt="">はノードi, jを接続するための仮想の測定値の入った情報行列である。この仮想測定は、iから取得した観測値とjから取得した観測値が最大限に重なるように変換したものだ。<img src="public01/pic/Formula09.png" alt="">はノード xi, xj が与えられたときの可能の測定値を示す。<br>
		<br>
		<img src="public01/pic/Formula10.png" alt="">は観測した ^z_ij と実際の z_ij との誤差を示す。表記を簡単にするために、測定値の指標を誤差関数の指標で表す。

		<div class="figure">
			<img src="public01/pic/Formula11.png" alt="">
			<div class="figure-text">式02 誤差関数</div>
		</div>

		図2は、グラフのエッジを定義するための関数とその量を示したものである。 最尤法の目的は、すべての観測値の負の対数尤度 <b>F(x)</b> を最小にするノードx∗の構成を見つけることである。

		<div class="figure">
			<img src="public01/pic/Formula12.png" alt="">
			<div class="figure-text">式03 目的関数<b>F(x)</b></div>
		</div>

		<div class="figure">
			<img src="public01/pic/ABird's-eyeViewOfTheCeremony.png" alt="">
			<div class="figure-text">図02 グラフのエッジを定義するための関数とその量</div>
			<div class="figure-description">
				xi と xj の接続を示す図。これらは計測値 zij に由来する。xi, xjから逆に計測値 ^zの計算も可能である。eij は誤差関数を示し、実際の測定値と期待した測定値との誤差を表す。エッジはその誤差関数とその不確かさを測定する情報行列 Ωij によって特徴づけられる。
			</div>
		</div>

		本節では、式03 中の x* に関する式を解き、ロボットの軌道に対する事後評価を正規分布への近似で求める方法を説明する。

		<h3><i>反復的局所線形化による誤差最小化</i></h3>
		ロボットの姿勢の初期推定値̆xがわかっていれば、一般的なガウス・ニュートン法またはLevenberg-Marquardtアルゴリズムを使用して、式03のx*の数値解を得ることができる。それには、現在の初期推定値̆xを中心とした一次テイラー展開によって誤差関数を近似することでできる。

		<div class="figure">
			<img src="public01/pic/Formula13.png" alt="">
		</div>
		J_ijはe_ij(x)のヤコビ行列を示す。この(7)の式を式03のF(x)の式に代入すると
		<div class="figure">
			<img src="public01/pic/Formula14.png" alt="">
		</div>
		となる。そして局所近似により次のように書き換えることが出来る。
		<div class="figure">
			<img src="public01/pic/Formula15.png" alt="">
		</div>
		<img src="public01/pic/Formula17.png" alt="">とすることで(13) から (14) の変換を行っている。そしてΛxを最小化することで解くことが可能である。
		<div class="figure">
			<img src="public01/pic/Formula16.png" alt="">
		</div>

		行列Hは測定誤差をヤコビ行列を通して軌道の空間に投影することが出来る。構造上、Hは疎な行列であり、制約によって接続されたポーズには0がない。非ゼロのブロック数は制約の数の２倍です。これにより式(15)を<b>Sparse Cholesky</b>により解くことが出来る。線形化された解は、計算された増分を初期推測に加えることで得られる。<br>
		<div class="figure">
			<img src="public01/pic/Formula18.png" alt="">
		</div>
		一般的なガウス・ニュートン法は(14)の線形化、(15)の解、(16)の更新の繰り返しである。各反復では前回の結果が用いられる。上記の手順は一般的なアプローチであり、パラメータxがユークリッドであることを前提としている。そのため、SLAMでは有効でない可能性もある。

		<div class="comment">
			この式(16)で求められた x* が上の式03内の<b>観測値の負の対数尤度 F(x) を最小にするノードの構成</b>である。
		</div>

		<h3><i>線形化されたシステムへの考察</i></h3>
		式(14)から、行列Hとベクトルbは、制約ごとに1つずつの行列とベクトルを合計することで得られる。全ての制約条件はシステムに負荷項をもたらす。この加算による構造は誤差関数のヤコビ行列に依存する。制約の誤差関数は2つのノードの値にのみ依存するため、(7)のヤコビ行列は次のような形になる。

		<div class="figure">
			<img src="public01/pic/Formula19.png" alt="">
		</div>

		ここで、AijとBijは、xiとxjに対する誤差関数の微分である。式(10)から、ブロック行列Hijの構造は次のようになる。

		<div class="figure">
			<img src="public01/pic/Formula20.png" alt="">
		</div>

		(見やすさの為に０は省略している。)<br>
		<br>
		アルゴリズム1は、ロボットの姿勢に関する事後情報の平均値と情報行列を決定する反復的なガウス・ニュートン法を要約したものである。システムのほとんどの構造は疎であるため、システムのヘッセ行列Hを保存するには、メモリ効率の良い表現を使用したほうが良い。ヘッセ行列の構造は、グラフの接続性から事前に知られているので、反復の最初に一度だけヘッセ行列を事前に割り当て、新たな線形化が必要なときに、すべてのエッジをループしてその場で更新したほうが良い。 各エッジは、ブロックH[ii]、H[ij]、H[ji]、H[jj]と、係数ベクトルのブロックb[i]およびb[j]に寄与する。さらに、Hの上三角部は対称的なので、上三角部のみを計算するという最適化も行われている。なお、制約条件 ij の誤差は、連結されたポーズ xi と xj の相対的な位置関係にのみ依存する．したがって、ポーズxの特定の構成の誤差F(x)は、すべてのポーズの剛体変換の下で不変である。この結果、式15は過小評価されることとなる。このシステムを数値的に解くためには、増分Δxkの1つをゼロに拘束するのが一般的である。これは、k番目の対角線ブロックH[kk]に恒等行列を加えることで可能である。<br>
		アルゴリズム1では、一般性を損なわないように、最初のノードex1を固定する。ポーズ・グラフの特定のノードを固定する別の方法は、式15の線形システムのk番目のブロックの行とk番目のブロックの列を抑制することである。

		<div class="algorithm">
			<div class="algorithm-title"><b>Algorithm 01：</b>制約条件のグラフからロボットの姿勢の多変量正規近似の平均x∗と情報量<b>H∗</b>の計算</div>
			<div class="algorithm-content">
				<img src="public01/pic/Algorithm01.png" alt="">
			</div>
		</div>

		<h3><i>多様体における最小二乗法</i></h3>
		非ユークリッド空間を扱う数値計算では，多様体上で最適化を行うのが一般的なアプローチである．<b>多様体(マニフォールド)</b>とは、大局的には必ずしもユークリッドではないが、局所的にはユークリッドとみなすことができる数学的空間である。<br>
		SLAM問題の文脈では、各パラメータブロックxiは、並進ベクトルtiと回転成分αiで構成される。 並進ベクトルtiは明らかにユークリッド空間を形成し、回転成分αiは非ユークリッドの2Dまたは3D回転群SO(2)またはSO(3)にわたっている。 特異点を避けるために、これらの空間は通常、回転行列や四元数などで過剰にパラメトリックに記述される。 式(16)をこれらのオーバーパラメトリックな表現に直接適用すると、オーバーパラメトリックな表現による制約が崩れてしまう。過剰なパラメータ化は自由度を増やすことになるため、解答に誤差が生じる。この問題を解決するには、回転のための最小の表現（例えば、3Dのオイラー角のような）を使用することができる。 しかし、これには特異点がある。 別のアイデアとして、基礎となる空間を多様体と考え、ユークリッド空間の局所的な変化Δxを多様体上の変化Δx7→x⊞Δxにマッピングする演算子⊞を定義することができる。この演算子を用いて、新しい誤差関数を次のように定義することができる。

		<div class="comment">
			1. SLAMには回転という概念があるため、<b>非ユークリッド空間</b>になると思われる。<br>
			2. <b>特異点</b>はエッジケース(特殊なケース)を指すと思われる。しかし、実際に特異点という意味で用いている可能性もあるのでそのままにしておく。
		</div>

		<div class="figure">
			<img src="public01/pic/Formula21.png" alt="">
		</div>

		ここで, ˘x は元のオーバーパラメトリック空間（例えば四元数）にわたっている。 ∆̃x は、元の位置̆xの周りの小さな増分であり、最小の表現で表される。<br>
		例として、3D SLAMでは、回転のパラメータ化には、単位四元数のベクトル部分が適している。 具体的には、増分 Δ̃x を6次元ベクトル <img src="public01/pic/Formula22.png" alt="">で表すことができる。ここで、Δ̃t は並進を表し<img src="public01/pic/Formula23.png" alt="">は3次元回転を表す単位四元数のベクトル部分である。逆に<img src="public01/pic/Formula24.png" alt="">は回転部分を符号化するために四元数 ˘q を使用する。このように、演算子⊞は、まず△̃qを完全な四元数△qに変換し、次に<img src="public01/pic/Formula25.png" alt="">という変換を△xに適用することで表すことができる。 誤差の最小化を記述する方程式では、これらの操作は⊞演算子によってうまくカプセル化される。 ヤコビ行列 ˘jij は次のように表されます。
		<div class="figure">
			<img src="public01/pic/Formula26.png" alt="">
		</div>
		前の式でeは△̃xiと△̃xjにのみ依存するので、さらに次のように展開できる。
		<div class="figure">
			<img src="public01/pic/Formula27.png" alt="">
		</div>
		偏微分のルールを使い、ヤコビ行列が △̃x=0 で評価されることを利用して、非ゼロブロックは次のようになる。
		<div class="figure">
			<img src="public01/pic/Formula28.png" alt="">
		</div>
		したがって、式17の多様体上で定義されないヤコビ行列から、その非ゼロブロックに、̆xiと̆xjで計算された⊞演算子の微分を乗じるだけで、多様体上のヤコビ行列を容易に導き出すことができる。表記を簡単に拡張すると，式(9)に式(21)を挿入することができ、次のような連立方程式が導かれる。
		<div class="figure">
			<img src="public01/pic/Formula29.png" alt="">
		</div>
		増分Δ̃x∗は、初期推測値̆xの局所的なユークリッド環境で計算されるため、⊞演算子によって元のオーバーパラメトリック空間に再マッピングする必要がある。したがって、式(16)は次のようになる。
		<div class="figure">
			<img src="public01/pic/Formula30.png" alt="">
		</div>
		したがって、多様体上で最小化問題を形式化することは、まず式(26)によって初期推測の周りの局所ユークリッド近似で増分のセットを計算し、次に式(27)によって大域的な非ユークリッド空間で増分を累積することである。 多様体表現で計算された線形システムは、ユークリッド空間で計算された線形システムと同じ構造を持っていることに注意する必要がある。 アルゴリズム2は、SLAMのためのガウス・ニュートン法の多様体バージョンである。<br>
		多様体問題のヘッセ行列˘Hは、もはや軌道の情報行列ではなく、軌道の増分Δ̃xの情報行列を表している。軌道の情報行列を得るために、アルゴリズム2はポーズxの元の空間でHを計算する

		<div class="algorithm">
			<div class="algorithm-title"><b>Algorithm 02：</b>アルゴリズム1の多様体版。計算量は変わらないが、特に3Dの場合には、ロバスト性が大幅に向上している。</div>
			<div class="algorithm-content">
				<img src="public01/pic/Algorithm02.png" alt="">
			</div>
		</div>

		<h2>実践</h2>
		このセクションでは、提案した手法のいくつかのアプリケーションについて説明する。 最初のシナリオでは、完全な2Dマッピングシステムを説明し、2番目のシナリオでは、3Dマッピングシステムを簡単に説明し、多様体表現の利点を強調する。

		<h3><i>2D レーザーベースの地図生成</i></h3>
		シアトルのIntel研究所でレーザーによる距離センサを搭載した移動ロボットを用いて地図生成を行った。このデータは連続した時間フレーム間のプラットフォームの動きに対応する2次元変換を記述したオドメトリ測定値と、2次元のレーザー距離データで構成されている。<br>
		グラフは次のように構築される。<br>
		<ol>
			<li>ロボットが0.5メートル以上移動したり、0.5ラジアン(28.6度)以上回転したりするたびにグラフに新しい頂点を追加し、現在のレーザー観測値をラベル付けする。</li>
			<li>レーザースキャンを先に取得したオドメトリ推定値と照合し，対応するエッジをグラフに追加する。ここでは、Olsonのスキャンマッチャーを応用している。</li>
			<li>
				ロボットが未知の領域を長時間移動した後、既知の領域に再び入ると、<b>ループ閉じ込み</b>を行い、スキャンと過去の測定値の一致を求める。現在の観測値と他のノードの観測値との間のマッチングが成功した場合、グラフに新しいエッジを追加する。このエッジには、2つのスキャンが最もよく重なり合うような相対的な変換がラベル付けされている。現在の測定値を以前のすべてのスキャンと一致させることは、ロボットの位置に関する既知の事前情報を考慮していないため、非常に効率が悪く、エラーが発生しやすい。 その対策として，過去のノード候補を，3σ限界共分散が現在のロボットのポーズを含むものとして選択する． これらの共分散は，縮小ヘッセ行列Hredの逆数の対角線ブロックとして得られる．HredはHから，新たに挿入されたロボットポーズの行と列を削除して得られる．Hredは，現在の位置を固定したと仮定したときの，すべての軌道の情報行列である．
			</li>
			<li>
				ループ閉じ込みが検知されるたびに最適化を行う。
			</li>
		</ol>
		実行終了時には、グラフは<b>1,802個のノードと3,546個のエッジ</b>で構成されていた。 このような比較的大きな問題でも、標準的なノートパソコン（Intel Core2@2.4 GHz）であれば、<b>100ミリ秒で最適化を行う</b>ことができる。ロボットの移動速度は約1m/sであるため、グラフの最適化は、ループ閉じ込みを検出した後ではなく、すべてのノードを追加した後に実行したほうが良い。図3は最適化処理による軌道への影響を、図4は不確かさの楕円を示している。ロボットは、楕円が小さくなる領域に位置している。  なお、SE(2)のポーズは過度なパラメータを要求しないので、多様体を利用するメリットはない。

		<div class="figure">
			<img src="public01/pic/DifferenceWithOrWithoutOptimum.png" alt="">
			<div class="figure-text">図03 最適化の有無による形成される地図の違い</div>
			<div class="figure-description">
				左：最適化されていないポーズグラフと地図<br>
				右：最適化されたポーズグラフと地図
			</div>
		</div>

		<div class="figure">
			<img src="public01/pic/PoseUncertaintyEstimateForAReal-worldDataSet.png" alt="">
			<div class="figure-text">図04 実世界のデータセットに対するポーズの不確実性評価</div>
		</div>

		<h3><i>3D レーザーベースの地図生成</i></h3>
		前節で紹介したSLAMアルゴリズムを3Dに拡張することは、非常に簡単だ。 2Dスキャンマッチングとループ閉じ込み検出を、単一のレーザースキャンではなく、3D点群で動作する3D対応のものに置き換えるだけである。さらに、グラフの各ノードと各制約条件はSE(3)に含まれる。<br>
		SE(3)の要素を表現するのに必要な最小のパラメータ数は6である(3次元の並進ベクトルと3つのオイラー角)。このパラメータ化を利用すると、アルゴリズム1が得られる。しかし、この最小の表現には特異点があり、これを回避するにはパラメータ化された状態空間を利用する必要がある。 また、最適化問題Δ̃xの相対的な摂動を最小限の表現で記述しつつ、ポーズを元のオーバーパラメトリック空間に残すこともできる。 これはアルゴリズム2につながる。 このセクションでは、シミュレーションされたロボットによって得られたポーズグラフ上で、最適化アルゴリズムのこれらの2つのバリエーションを比較する。ヘッセ行列のスパースパターンはどちらも同じであることには注意しましょう。 さらに、線形システムを計算する時間は、それを解決する時間に比べて無視できる程度である。したがって、パラメータ化の選択は主に収束速度に影響し、1回の反復に必要な時間には影響を受けない。この効果を強調するために、2つのアルゴリズムを用いて1回の最適化実行中の反復ごとの誤差の変化を示す。<br>
		ここでは，球体の表面を走行するロボットの3Dデータセットをシミュレーションした． 測定値には大きな誤差があり、オドメトリ情報を使用してシステムを初期化した結果、図11の左部分に示すグラフが得られた。 この初期推測から出発して，ガウス・ニュートン・アルゴリズムを，多様体の線形化を行った場合と行わなかった場合(すなわちオイラー角を使用するか否か)比較しながら実行した．図12は、2つのアプローチの反復処理中の誤差の変化を示している。 まず、どちらのアプローチも誤差を減らすことができた。 しかし、特異点を適切に考慮しないと、アルゴリズム1は発散してしまうが、アルゴリズム2は正しい解に収束する。

		<div class="figure">
			<img src="public01/pic/Pose-graphObtainedBySimulatingARobotMovingOnASphere.png" alt="">
			<div class="figure-text">図05 球体上を移動するロボットをシミュレーションして得られたポーズグラフ</div>
			<div class="figure-description">
				左：初期設定<br>
				右：最適化を行い、完全に復元された球体
			</div>
		</div>

		<div class="figure">
			<img src="public01/pic/EvolutionOfTheErrorF(x).png" alt="">
			<div class="figure-text">図06 3D球体データセットに対するオイラー角を用いたガウス・ニュートン最適化と多様体線形化による誤差F(x)の変化。</div>
		</div>

		<h2>結論</h2>
		本稿では、グラフベースのSLAMに関するチュートリアルを紹介した。その目的は、提案された手法を簡単に実装できるよう、読者に十分な詳細と洞察を提供することである。本論文で紹介したアルゴリズムでも、十分なパフォーマンスを発揮するが、これらのアルゴリズムを更に最適化すると、更に驚くほど大きな問題を扱うことができる。
	</div>
</body>
</html>